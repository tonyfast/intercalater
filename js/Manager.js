// Generated by CoffeeScript 1.10.0
(function() {
  var DataSource, Manager, Plot, Selection, Table, VirtualScroll,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Manager = (function() {

    /*
    One Data Source for many selections
    Attaches event driven data tress to selections
    Selections in a manager share a data source
     */
    function Manager(data1) {
      this.data = data1;

      /* @data changes state many times */
      this.DataSource = new Manager.DataSource(this.data);
      this.Selections = [];
    }

    Manager.prototype.attach = function(selection, SelectionType, name, config) {

      /* Attach a new selection to the manager */
      var id, selections_list;
      selections_list = this.Selections.filter((function(_this) {
        return function(s) {
          return s.selection.node() === selection.node();
        };
      })(this));
      if (selections_list.length === 0) {
        id = this.Selections.push(new SelectionType(selection, name, this.DataSource.tree, config));
        return this.Selections[id - 1];
      } else {
        return selections_list[0];
      }
    };

    return Manager;

  })();

  DataSource = (function() {

    /*
    A data source manages raw and derived data for different selections.  A data source can
    have many selections.  The raw data is expected to be in a split format
    
    data: mxn
    columns: n x 1
    index: m x 1
     */
    function DataSource(data1) {
      var column, column_index, columns, j, len, ref1;
      this.data = data1;
      console.log(Baobab);
      this.tree = new Baobab(this.data);
      if (this.tree.select('columns').exists()) {
        ref1 = columns = this.get('columns');
        for (column_index = j = 0, len = ref1.length; j < len; column_index = ++j) {
          column = ref1[column_index];

          /* Create Dynamic Nodes for Each Column Data Source */
          this.addColumnDataSource(column);
        }
      }
      if (this.tree.select('index').exists()) {

        /* Create a data source for the index */
        this.addColumnDataSource('index', Baobab.monkey(['index'], function(data) {
          return data;
        }));
      }
    }

    DataSource.prototype.updateIndex = function(new_index) {

      /* Set sorted data and indices */
      this.set('data', d3.permute(this.get('data'), new_index.map((function(_this) {
        return function(value) {
          return _this.ColumnDataSource('index').indexOf(value);
        };
      })(this))));
      this.set('index', new_index);
      return this;
    };

    DataSource.prototype.addDerivedDataSource = function(name, columns, f) {

      /* return the new data source */
      var cursor, data;
      cursor = this.tree.select('columns');
      cursor.push(name);
      this.addColumnDataSource(name, Baobab.monkey.apply(Baobab, slice.call(columns.map((function(_this) {
        return function(value) {
          return ['ColumnDataSource', value, 'data'];
        };
      })(this))).concat([f])));
      data = cursor.get().map((function(_this) {
        return function(column_name) {
          return _this.ColumnDataSource(column_name);
        };
      })(this));
      this.tree.set('data', d3.zip.apply(d3, data));
      return this.ColumnDataSource(name);
    };

    DataSource.prototype.ColumnDataSource = function(column_name) {
      if (Array.isArray(column_name)) {
        return d3.zip.apply(d3, column_name.map((function(_this) {
          return function(c) {
            return _this.get('ColumnDataSource', c, 'data');
          };
        })(this)));
      } else {
        return Array.apply(null, this.get('ColumnDataSource', column_name, 'data'));
      }
    };

    DataSource.prototype.addColumnDataSource = function(column, monkey) {
      if (monkey == null) {
        monkey = Baobab.monkey(['data'], ['.', 'name'], ['columns'], function(data, name, columns) {
          var column_index;
          column_index = columns.indexOf(name);
          return data.map((function(_this) {
            return function(value) {
              return value[column_index];
            };
          })(this));
        });
      }
      return this.set(['ColumnDataSource', column], {
        name: column,
        data: monkey
      });
    };

    DataSource.prototype.sort = function(columns, direction) {
      var MultiSort, sorted;
      if (direction == null) {
        direction = 'ascending';
      }

      /* Multisort on an */
      MultiSort = function(a, b, direction, i) {
        var ref1;
        if (direction == null) {
          direction = 'ascending';
        }
        if (i == null) {
          i = 0;
        }

        /* Multisorting function in d3 */
        ref1 = [parseFloat(a[i]), parseFloat(b[i])], a[i] = ref1[0], b[i] = ref1[1];
        if (a[i] === b[i]) {
          MultiSort(a, b, direction, i + 1);
        }
        return d3[direction](a[i], b[i]);
      };
      columns = !Array.isArray(columns) ? [columns] : columns;
      sorted = d3.zip.apply(d3, slice.call(columns.map((function(_this) {
        return function(c) {
          return _this.ColumnDataSource(c);
        };
      })(this))).concat([this.ColumnDataSource('index')])).sort(function(a, b) {
        return MultiSort(a, b, direction);
      });
      this.updateIndex(sorted.map(function(value) {
        return value[columns.length];
      }));
      return this;
    };

    DataSource.prototype.order = function() {

      /* Order the original indices */
      return this.sort('index');
    };

    DataSource.prototype.shuffle = function() {

      /* Randomly Sort the Indices */
      return this.updateIndex(d3.shuffle(this.ColumnDataSource('index')));
    };

    DataSource.prototype.get = function() {
      var args, ref1;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref1 = this.tree).get.apply(ref1, args);
    };

    DataSource.prototype.set = function() {
      var args, ref1;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref1 = this.tree).set.apply(ref1, args);
    };

    return DataSource;

  })();

  Selection = (function() {
    function Selection(selection1, name1, tree1, config) {
      this.selection = selection1;
      this.name = name1;
      this.tree = tree1;
      this.tree.set([this.name], config);
      this.cursor = this.tree.select([this.name]);
    }

    Selection.prototype.update = function(selection, selector, data, direction) {
      var classes, ref1, tag;
      if (direction == null) {
        direction = 'down';
      }

      /* Repeatable pattern for creating, updating, and removing data dependent dom elements */
      ref1 = selector.split('.'), tag = ref1[0], classes = 2 <= ref1.length ? slice.call(ref1, 1) : [];
      selection = selection.selectAll(selector).data(data);
      if (direction === 'right' || direction === 'down') {
        selection.enter().append(tag);
      } else if (direction === 'left' || direction === 'up') {
        selection.enter().insert(tag, ':first-child');
      }
      classes.forEach((function(_this) {
        return function(c) {
          return selection.classed(c, true);
        };
      })(this));
      selection.exit().remove();
      return selection;
    };

    Selection.prototype.clear = function() {
      return this.selection.html('');
    };

    return Selection;

  })();

  Plot = (function(superClass) {
    var from_ref;

    extend(Plot, superClass);

    from_ref = function(ref) {
      return Bokeh.Collections(ref.type).get(ref.id);
    };

    Plot.prototype.config = {
      ColumnDataSource: Baobab.monkey(['ColumnDataSource'], ['columns'], ['index'], function(cds, columns, index) {
        var updated;
        updated = {};
        columns.forEach((function(_this) {
          return function(k) {
            return updated[k] = cds[k]['data'];
          };
        })(this));
        return updated;
      })
    };

    function Plot(selection, name, tree, config1) {
      this.config = config1;
      Plot.__super__.constructor.call(this, selection, name, tree, this.config);
    }

    Plot.prototype.load = function(p) {
      debugger;
      var plot, view;
      plot = p['payload'].filter(function(d) {
        var ref1;
        return (ref1 = d.type) === 'Plot';
      });
      Bokeh.load_models(p['payload']);
      this.figure = from_ref(plot[0]);
      view = new this.figure.default_view({
        model: this.figure,
        el: '#' + this.selection.attr('id')
      });
      delete p['payload'];
      this.cursor.set(p);
      this.cds = from_ref(this.cursor.get('refs', 'source'));
      this.select = this.cds.get('selected');
      return this.updateDataSource();
    };

    Plot.prototype.updateDataSource = function() {
      var cds, new_source, old_source;
      new_source = this.cursor.get('ColumnDataSource');
      cds = from_ref(this.cursor.get('refs', 'source'));
      old_source = cds.get('data');
      d3.entries(new_source).forEach((function(_this) {
        return function(n) {
          return old_source[n.key] = n.value;
        };
      })(this));
      cds.set('data', old_source);
      return cds;
    };

    Plot.prototype.updateSelected = function() {
      this.select['1d']['indices'] = this.tree.get('table', 'index');
      this.cds.set('selected', this.select);
      return this.cds.trigger('select');
    };

    return Plot;

  })(Selection);

  Table = (function(superClass) {
    extend(Table, superClass);

    Table.prototype.config = {
      max_rows: 10,
      iloc: 0,
      show_id: true,
      index: Baobab.monkey(['.', 'max_rows'], ['.', 'iloc'], ['index'], function(rows, iloc, index) {
        return d3.range(iloc, iloc + rows).map((function(_this) {
          return function(iloc) {
            return index[iloc];
          };
        })(this));
      }),
      columns: {
        index: ['index', 'species'],
        exclude: ['sepal_length'],
        order: Baobab.monkey(['.', 'index'], ['.', 'exclude'], ['columns'], function(index, exclude, columns) {
          return [
            index, columns.filter((function(_this) {
              return function(c) {
                return indexOf.call(index, c) < 0;
              };
            })(this)).filter((function(_this) {
              return function(c) {
                return indexOf.call(exclude, c) < 0;
              };
            })(this))
          ];
        }),
        values: Baobab.monkey(['ColumnDataSource'], ['..', 'index'], ['.', 'order'], function(cds, index, order) {
          var v;
          v = d3.merge(order).map((function(_this) {
            return function(column) {
              return index.map(function(i) {
                return cds[column]['data'][i];
              });
            };
          })(this));
          return d3.zip.apply(d3, v);
        })
      }
    };

    function Table(selection, name, tree) {
      Table.__super__.constructor.call(this, selection, name, tree, this.config);
      this.tree.set(['table'], this.config);
      this.build();
    }

    Table.prototype.build = function() {
      var _t, heading, left_heading, order, right_heading, table, table_cursor, values;
      table_cursor = this.tree.select('table');
      table = this.update(this.selection, 'table', [1]);
      order = table_cursor.get('columns', 'order');
      left_heading = order[0], right_heading = order[1];
      heading = this.update(table, 'tr.heading', [order], 'up');
      _t = this;
      heading.each(function(columns) {
        _t.update(d3.select(this), 'th.index', left_heading, 'left').text(function(d) {
          return d;
        });
        return _t.update(d3.select(this), 'th.value', right_heading, 'right').text(function(d) {
          return d;
        });
      });
      values = this.update(table, 'tr.values', table_cursor.get('columns', 'values'), 'down');
      return values.each(function(row_values) {
        _t.update(d3.select(this), 'th.index', left_heading, 'left');
        _t.update(d3.select(this), 'td.value', right_heading, 'right');
        return d3.select(this).selectAll('th.index,td.value').data(row_values).text(function(d) {
          return d;
        });
      });
    };

    return Table;

  })(Selection);

  VirtualScroll = (function(superClass) {
    var s;

    extend(VirtualScroll, superClass);

    s = function(v) {
      return v + "px";
    };

    VirtualScroll.prototype.config = {
      speed: 1,
      max_rows: Baobab.monkey(['table', 'max_rows'], function(v) {
        return v;
      }),
      rowHeight: 20,
      height: 800,
      width: 600,
      scroll_width: 50,
      size: Baobab.monkey(['index'], function(v) {
        return v.length;
      })
    };

    function VirtualScroll(selection, name, tree) {
      var _this;
      VirtualScroll.__super__.constructor.call(this, selection, name, tree, this.config);
      _this = this;
      this.cursor = this.tree.select(['scroll']);
      this.cursor.set(this.config);
      this.parent = d3.select(this.selection.property('parentNode'));
      this.before = this.update(this.parent, 'div.before.longscroll', [0], 'up');
      this.current = this.update(this.parent, 'div.current.longscroll', [0], 'down');
      this.after = this.update(this.parent, 'div.after.longscroll', [0], 'down');
      this.updateSize();
      console.log(this.parent);
      this.parent.on('scroll.longscroll', function() {
        var position;
        position = Math.floor(_this.offset(this.scrollTop, 'screen-data'));
        _this.updateSize();
        return _this.scroll(this.scrollTop, position);
      });
      this.scroll(0, this.tree.get('index', 0));
      this.build();
    }

    VirtualScroll.prototype.build = function() {
      var maxRows, ref1, size;
      ref1 = this.cursor.project([['max_rows'], ['size']]), maxRows = ref1[0], size = ref1[1];
      this.cursor.set(['rowHeight'], d3.mean(this.selection.selectAll('tr.rows')[0].map(function(t) {
        return t.offsetHeight;
      })));
      return this.updateSize();
    };

    VirtualScroll.prototype.scroll = function(scrollTop, position) {
      return this.current.call((function(_this) {
        return function(current) {
          current.property('scrollTop', scrollTop);
          position = d3.max([0, d3.min([_this.cursor.get('size') - _this.cursor.get('max_rows'), position])]);
          _this.before.style("height", s(_this.offset(position)));
          _this.after.style("height", s(_this.offset(_this.cursor.get('size') - position)));
          if (Math.abs(position - _this.tree.get('table', 'iloc')) >= 1) {
            _this.tree.select('table', 'iloc').set(position);
            return _this.render();
          }
        };
      })(this));
    };

    VirtualScroll.prototype.offset = function(v, method) {
      var scale;
      if (method == null) {
        method = "data-screen";
      }
      scale = d3.scale.linear().domain([0, this.cursor.get('size') - this.cursor.get('max_rows')]).range([0, this.cursor.get('size') * this.cursor.get('size')]).clamp(true);
      if (method === 'data-screen') {
        return scale(v);
      } else if (method === 'screen-data') {
        return Math.floor(scale.invert(v));
      }
    };

    VirtualScroll.prototype.updateSize = function() {
      this.selection.style({
        position: 'absolute',
        left: s(d3.select(this.selection.property('parentNode')).property('offsetLeft')),
        top: s(d3.select(this.selection.property('parentNode')).property('offsetTop')),
        'margin-top': s(0)
      });
      return this.parent.style({
        'overflow-y': 'auto',
        height: s(this.selection.property('offsetHeight')),
        width: s(this.cursor.get('scroll_width') + this.selection.property('offsetWidth')),
        'background-color': 'cyan'
      });
    };

    VirtualScroll.prototype.render = function() {};

    return VirtualScroll;

  })(Selection);

  Manager.Selection = Selection;

  Manager.DataSource = DataSource;

  window.VirtualScroll = VirtualScroll;

  window.Plot = Plot;

  window.Table = Table;

  window.Manager = Manager;

}).call(this);
